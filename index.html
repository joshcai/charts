<!DOCTYPE html>
<html>

<head>
	<title>charts</title>
	<meta name="viewport" content="width=device-width,initial-scale=1.0">
	<script src="https://d3js.org/d3.v5.min.js"></script>
	<link href="https://fonts.googleapis.com/css?family=Inconsolata&display=swap" rel="stylesheet">
	<style>
		/* Colors: https://coolors.co/f1e0c5-22333b-2afc98-5d737e-14bdeb */
		body, .axis {
			font-family: 'Inconsolata', monospace;
			background-color: #22333B;
			color: #eee;
		}
		#title {
			text-align: center;
			font-size: 40px;
			color: #14BDEB;
		}
		.grid {
			color: #F1E0C5;
			opacity: 0.3;
		}
		.dot {
			fill: #2AFC98;
		}
	</style>
</head>

<body>
	<h2 id="title">Wake up time</h2>
	<div id="wake-up-chart"></div>	
</body>

<script>

	// Set the dimensions and margins of the chart.
	const margin = {top: 10, right: 40, bottom: 30, left: 60};
	const height = 400 - margin.top - margin.bottom;
	const width = 900 - margin.left - margin.right;

	// Append the svg object to the wake-up-chart element.
	const svg = d3.select('#wake-up-chart')
	.append('svg')
		.attr('preserveAspectRatio', 'xMinYMin meet')
		.attr('viewBox', '0 0 900 400')
		.classed('svg-content', true)
	.append('g')
		.attr('transform',
			'translate(' + margin.left + ',' + margin.top + ')');

	const xhr = new XMLHttpRequest();
	xhr.open('GET', 'https://trello.com/1/lists/5cfd62ede5123b86dff74e90/cards?fields=name');
	xhr.onreadystatechange = function() {
		if (xhr.readyState !== 4 || xhr.status !== 200) {
			return;
		}
		const cards = JSON.parse(xhr.responseText);
		const parseTime = d3.timeParse('%H:%M');
		// Reverse cards since we want to see most recent.
		const transformedCards = cards.reverse().slice(0, 90).map(card => ({
			// Card creation date is stored as part of the card id.
			date: new Date(parseInt(card.id.substring(0, 8), 16) * 1000),
			wakeUpTime: parseTime(card.name),
		}));

		// Pad the min / max of X axis with 1 day to avoid points falling on the axis / end grid line.
		const minDate = new Date(transformedCards[transformedCards.length-1].date);
		minDate.setDate(minDate.getDate() - 1);
		const maxDate = new Date(transformedCards[0].date);
		maxDate.setDate(maxDate.getDate() + 1);

		// Add X axis.
		const dateAxis = d3.scaleTime()
			.domain([minDate, maxDate])
			.range([0, 800]);
		svg.append('g')
			.attr('transform', 'translate(0,' + height + ')')
			.attr('class', 'axis')
			.call(d3.axisBottom(dateAxis).tickSizeOuter(0).tickFormat(d3.timeFormat('%m/%d')));

		// Add Y axis.
		const wakeUpTimeAxis = d3.scaleTime()
		    .domain([parseTime('05:00'), parseTime('11:00')])
		    .range([height, 0]);
		svg.append('g')
			.attr('class', 'axis')
			.call(d3.axisLeft(wakeUpTimeAxis));

		// Add the X gridlines.
		svg.append('g')			
			.attr('class', 'grid')
			.attr('transform', 'translate(0,' + height + ')')
			.call(d3.axisBottom(dateAxis).ticks(3).tickSize(-height).tickFormat(''));

		// Add the Y gridlines.
		svg.append('g')			
			.attr('class', 'grid')
			.call(d3.axisLeft(wakeUpTimeAxis).ticks(4).tickSize(-width).tickFormat(''));

		// Add dots.
		svg.append('g')
			.selectAll('dot')
			.data(transformedCards)
			.enter()
			.append('circle')
				.attr('cx', function (d) { return dateAxis(d.date); } )
				.attr('cy', function (d) { return wakeUpTimeAxis(d.wakeUpTime); } )
				.attr('r', 4)
				.attr('class', 'dot');
	};
	xhr.send();
</script>

</html>
